(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{495:function(t,_,e){"use strict";e.r(_);var v=e(0),n=Object(v.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"tensor创建函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tensor创建函数"}},[t._v("#")]),t._v(" Tensor创建函数")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("用法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("tf.zeros(shape, dtype=tf.float32, name=None)")]),t._v(" "),e("td",[t._v("创建所有元素设置为零的张量")])]),t._v(" "),e("tr",[e("td",[t._v("tf.zeros_like(tensor, dtype=None, name=None)")]),t._v(" "),e("td",[t._v("返回tensor与所有元素设置为零相同的类型和形状的张量")])]),t._v(" "),e("tr",[e("td",[t._v("tf.ones(shape, dtype=tf.float32, name=None)")]),t._v(" "),e("td",[t._v("创建一个所有元素设置为1的张量。")])]),t._v(" "),e("tr",[e("td",[t._v("tf.ones_like(tensor, dtype=None, name=None)")]),t._v(" "),e("td",[t._v("返回tensor与所有元素设置为1相同的类型和形状的张量")])]),t._v(" "),e("tr",[e("td",[t._v("tf.fill(dims, value, name=None)")]),t._v(" "),e("td",[t._v("创建一个填充了标量值的张量")])]),t._v(" "),e("tr",[e("td",[t._v("tf.truncated_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)")]),t._v(" "),e("td",[t._v("从截断的正态分布中输出随机值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.random_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)")]),t._v(" "),e("td",[t._v("从正态分布中输出随机值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.random_uniform(shape, minval=0.0, maxval=1.0, dtype=tf.float32, seed=None, name=None)")]),t._v(" "),e("td",[t._v("从均匀分布输出随机值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.eye(num_rows, num_columns=None, batch_shape=None, dtype=tf.float32, name=None)")]),t._v(" "),e("td",[t._v("构建一个单位矩阵, 或者 batch 个矩阵，batch_shape 以 list 的形式传入")])]),t._v(" "),e("tr",[e("td",[t._v("tf.diag(diagonal, name=None)")]),t._v(" "),e("td",[t._v("构建一个对角矩阵")])]),t._v(" "),e("tr",[e("td",[t._v("tf.global_variables_initializer()")]),t._v(" "),e("td",[t._v("初始化全部变量")])])])]),t._v(" "),e("h2",{attrs:{id:"tensor转换函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tensor转换函数"}},[t._v("#")]),t._v(" Tensor转换函数")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("用法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("tf.random_shuffle(value, seed=None, name=None)")]),t._v(" "),e("td",[t._v("沿其第一维度随机打乱")])]),t._v(" "),e("tr",[e("td",[t._v("tf.set_random_seed(seed)")]),t._v(" "),e("td",[t._v("设置图级随机种子")])]),t._v(" "),e("tr",[e("td",[t._v("tf.string_to_number(string_tensor, out_type=None, name=None)")]),t._v(" "),e("td",[t._v("张量变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.to_double(x, name='ToDouble')")]),t._v(" "),e("td",[t._v("张量变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.to_float(x, name='ToFloat')")]),t._v(" "),e("td",[t._v("张量变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.to_bfloat16(x, name='ToBFloat16')")]),t._v(" "),e("td",[t._v("张量变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.to_int32(x, name='ToInt32')")]),t._v(" "),e("td",[t._v("张量变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.to_int64(x, name='ToInt64')")]),t._v(" "),e("td",[t._v("张量变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.cast(x, dtype, name=None)")]),t._v(" "),e("td",[t._v("张量变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.shape(input, name=None)")]),t._v(" "),e("td",[t._v("用于确定张量的形状并更改张量的形状")])]),t._v(" "),e("tr",[e("td",[t._v("tf.size(input, name=None)")]),t._v(" "),e("td",[t._v("用于确定张量的形状并更改张量的形状")])]),t._v(" "),e("tr",[e("td",[t._v("tf.rank(input, name=None)")]),t._v(" "),e("td",[t._v("用于确定张量的形状并更改张量的形状")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reshape(tensor, shape, name=None)")]),t._v(" "),e("td",[t._v("用于确定张量的形状并更改张量的形状")])]),t._v(" "),e("tr",[e("td",[t._v("tf.squeeze(input, squeeze_dims=None, name=None)")]),t._v(" "),e("td",[t._v("用于确定张量的形状并更改张量的形状")])]),t._v(" "),e("tr",[e("td",[t._v("tf.expand_dims(input, dim, name=None)")]),t._v(" "),e("td",[t._v("用于确定张量的形状并更改张量的形状")])]),t._v(" "),e("tr",[e("td",[t._v("tf.slice(input_, begin, size, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.split(split_dim, num_split, value, name='split')")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.tile(input, multiples, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.pad(input, paddings, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.concat(concat_dim, values, name='concat')")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.pack(values, name='pack')")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.unpack(value, num=None, name='unpack')")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reverse_sequence(input, seq_lengths, seq_dim, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reverse(tensor, dims, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.transpose(a, perm=None, name='transpose')")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.gather(params, indices, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.dynamic_partition(data, partitions, num_partitions, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])]),t._v(" "),e("tr",[e("td",[t._v("tf.dynamic_stitch(indices, data, name=None)")]),t._v(" "),e("td",[t._v("切片与扩展")])])])]),t._v(" "),e("h2",{attrs:{id:"逻辑判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#逻辑判断"}},[t._v("#")]),t._v(" 逻辑判断")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("用法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("tf.logical_and(x, y, name=None)")]),t._v(" "),e("td",[t._v("逻辑运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.logical_not(x, name=None)")]),t._v(" "),e("td",[t._v("逻辑运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.logical_or(x, y, name=None)")]),t._v(" "),e("td",[t._v("逻辑运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.logical_xor(x, y, name='LogicalXor')")]),t._v(" "),e("td",[t._v("逻辑运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.equal(x, y, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.not_equal(x, y, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.less(x, y, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.less_equal(x, y, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.greater(x, y, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.greater_equal(x, y, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.select(condition, t, e, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.where(input, name=None)")]),t._v(" "),e("td",[t._v("比较运算符")])]),t._v(" "),e("tr",[e("td",[t._v("tf.is_finite(x, name=None)")]),t._v(" "),e("td",[t._v("判断检查")])]),t._v(" "),e("tr",[e("td",[t._v("tf.is_inf(x, name=None)")]),t._v(" "),e("td",[t._v("判断检查")])]),t._v(" "),e("tr",[e("td",[t._v("tf.is_nan(x, name=None)")]),t._v(" "),e("td",[t._v("判断检查")])]),t._v(" "),e("tr",[e("td",[t._v("tf.verify_tensor_all_finite(t, msg, name=None) 断言张量不包含任何NaN或Inf")]),t._v(" "),e("td",[t._v("判断检查")])]),t._v(" "),e("tr",[e("td",[t._v("tf.check_numerics(tensor, message, name=None)")]),t._v(" "),e("td",[t._v("判断检查")])]),t._v(" "),e("tr",[e("td",[t._v("tf.add_check_numerics_ops()")]),t._v(" "),e("td",[t._v("判断检查")])]),t._v(" "),e("tr",[e("td",[t._v("tf.Assert(condition, data, summarize=None, name=None)")]),t._v(" "),e("td",[t._v("判断检查")])]),t._v(" "),e("tr",[e("td",[t._v("tf.Print(input_, data, message=None, first_n=None, summarize=None, name=None)")]),t._v(" "),e("td",[t._v("判断检查")])])])]),t._v(" "),e("h2",{attrs:{id:"数学函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数学函数"}},[t._v("#")]),t._v(" 数学函数")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("用法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("tf.add(x, y, name=None)")]),t._v(" "),e("td",[t._v("加法(支持 broadcasting)")])]),t._v(" "),e("tr",[e("td",[t._v("tf.subtract(x, y, name=None)")]),t._v(" "),e("td",[t._v("减")])]),t._v(" "),e("tr",[e("td",[t._v("tf.multiply(x, y, name=None)")]),t._v(" "),e("td",[t._v("乘")])]),t._v(" "),e("tr",[e("td",[t._v("tf.divide(x, y, name=None)")]),t._v(" "),e("td",[t._v("除")])]),t._v(" "),e("tr",[e("td",[t._v("tf.mod(x, y, name=None)")]),t._v(" "),e("td",[t._v("取余")])]),t._v(" "),e("tr",[e("td",[t._v("tf.pow(x, y, name=None)")]),t._v(" "),e("td",[t._v("幂")])]),t._v(" "),e("tr",[e("td",[t._v("tf.square(x, name=None)")]),t._v(" "),e("td",[t._v("求平方")])]),t._v(" "),e("tr",[e("td",[t._v("tf.sqrt(x, name=None)")]),t._v(" "),e("td",[t._v("开方")])]),t._v(" "),e("tr",[e("td",[t._v("tf.exp(x, name=None)")]),t._v(" "),e("td",[t._v("自然指数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.log(x, name=None)")]),t._v(" "),e("td",[t._v("自然对数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.negative(x, name=None)")]),t._v(" "),e("td",[t._v("取相反数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.sign(x, name=None)")]),t._v(" "),e("td",[t._v("返回 x 的符号")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reciprocal(x, name=None)")]),t._v(" "),e("td",[t._v("取倒数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.abs(x, name=None)")]),t._v(" "),e("td",[t._v("求绝对值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.round(x, name=None)")]),t._v(" "),e("td",[t._v("四舍五入")])]),t._v(" "),e("tr",[e("td",[t._v("tf.ceil(x, name=None)")]),t._v(" "),e("td",[t._v("向上取整")])]),t._v(" "),e("tr",[e("td",[t._v("tf.floor(x, name=None)")]),t._v(" "),e("td",[t._v("向下取整")])]),t._v(" "),e("tr",[e("td",[t._v("tf.rint(x, name=None)")]),t._v(" "),e("td",[t._v("取最接近的整数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.maximum(x, y, name=None)")]),t._v(" "),e("td",[t._v("返回两tensor中的最大值 (x > y ? x : y)")])]),t._v(" "),e("tr",[e("td",[t._v("tf.minimum(x, y, name=None)")]),t._v(" "),e("td",[t._v("返回两tensor中的最小值 (x < y ? x : y)")])]),t._v(" "),e("tr",[e("td",[t._v("tf.cos(x, name=None)")]),t._v(" "),e("td",[t._v("三角函数和反三角函数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.sin(x, name=None)")]),t._v(" "),e("td",[t._v("三角函数和反三角函数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.tan(x, name=None)")]),t._v(" "),e("td",[t._v("三角函数和反三角函数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.acos(x, name=None)")]),t._v(" "),e("td",[t._v("三角函数和反三角函数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.asin(x, name=None)")]),t._v(" "),e("td",[t._v("三角函数和反三角函数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.atan(x, name=None)")]),t._v(" "),e("td",[t._v("三角函数和反三角函数")])]),t._v(" "),e("tr",[e("td",[t._v("tf.matmul(a,b,name=None)")]),t._v(" "),e("td",[t._v("矩阵乘法(tensors of rank >= 2)")])]),t._v(" "),e("tr",[e("td",[t._v("tf.transpose(a, perm=None, name='transpose')")]),t._v(" "),e("td",[t._v("转置，可以通过指定 perm=[1, 0] 来进行轴变换")])]),t._v(" "),e("tr",[e("td",[t._v("tf.trace(x, name=None)")]),t._v(" "),e("td",[t._v("求矩阵的迹")])]),t._v(" "),e("tr",[e("td",[t._v("tf.matrix_determinant(input, name=None)")]),t._v(" "),e("td",[t._v("计算方阵行列式的值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.matrix_inverse(input, adjoint=None, name=None)")]),t._v(" "),e("td",[t._v("求解可逆方阵的逆")])]),t._v(" "),e("tr",[e("td",[t._v("tf.svd(tensor, name=None)")]),t._v(" "),e("td",[t._v("奇异值分解")])]),t._v(" "),e("tr",[e("td",[t._v("tf.qr(input, full_matrices=None, name=None)")]),t._v(" "),e("td",[t._v("QR 分解")])]),t._v(" "),e("tr",[e("td",[t._v("tf.norm(tensor, ord='euclidean', axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("求张量的范数(默认2)")])])])]),t._v(" "),e("h2",{attrs:{id:"聚合相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#聚合相关"}},[t._v("#")]),t._v(" 聚合相关")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("用法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("tf.reduce_sum(input_tensor, axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("计算输入 tensor 所有元素的和，或者计算指定的轴所有元素的和")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reduce_mean(input_tensor, axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("求均值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reduce_max(input_tensor, axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("求最大值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reduce_min(input_tensor, axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("求最小值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reduce_prod(input_tensor, axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("求累乘")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reduce_all(input_tensor, axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("全部满足条件")])]),t._v(" "),e("tr",[e("td",[t._v("tf.reduce_any(input_tensor, axis=None, keep_dims=False, name=None)")]),t._v(" "),e("td",[t._v("至少有一个满足条件")])])])]),t._v(" "),e("h2",{attrs:{id:"序列比较与索引提取"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#序列比较与索引提取"}},[t._v("#")]),t._v(" 序列比较与索引提取")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("用法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("tf.setdiff1d(x, y, index_dtype=tf.int32, name=None)")]),t._v(" "),e("td",[t._v("比较两个 list 或者 string 的不同，并返回不同的值和索引")])]),t._v(" "),e("tr",[e("td",[t._v("tf.unique(x, out_idx=None, name=None)")]),t._v(" "),e("td",[t._v("返回 x 中的唯一值所组成的tensor 和原 tensor 中元素在现 tensor 中的索引")])]),t._v(" "),e("tr",[e("td",[t._v("tf.where(condition, x=None, y=None, name=None)")]),t._v(" "),e("td",[t._v("x if condition else y, condition 为 bool 类型的")])]),t._v(" "),e("tr",[e("td",[t._v("tf.argmax(input, axis=None, name=None, output_type=tf.int64)")]),t._v(" "),e("td",[t._v("返回沿着坐标轴方向的最大值的索引")])]),t._v(" "),e("tr",[e("td",[t._v("tf.argmin(input, axis=None, name=None, output_type=tf.int64)")]),t._v(" "),e("td",[t._v("返回沿着坐标轴方向的最小值的索引")])]),t._v(" "),e("tr",[e("td",[t._v("tf.invert_permutation(x, name=None)")]),t._v(" "),e("td",[t._v("x 的值当作 y 的索引，range(len(x)) 索引当作 y 的值")])]),t._v(" "),e("tr",[e("td",[t._v("tf.edit_distance(x,y)")]),t._v(" "),e("td",[t._v("编辑距离")])])])])])}),[],!1,null,null,null);_.default=n.exports}}]);