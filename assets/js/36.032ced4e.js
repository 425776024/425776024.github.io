(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{391:function(v,_,t){"use strict";t.r(_);var p=t(0),o=Object(p.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("#双向循环神经网络")]),v._v(" "),t("blockquote",[t("p",[v._v("前面介绍的循环神经网络是单向的，每一个时刻的输出依赖于比它早的时刻的输入值，这没有利用未来时刻的信息")]),v._v(" "),t("p",[v._v("有些问题，当前时刻的输出不仅与过去时刻的数据有关，还与将来时刻的数据有关，如机器翻译问题")]),v._v(" "),t("p",[v._v("因此用两个不同的循环层分别从正向和反向对数据进行扫描，可能效果更好")])]),v._v(" "),t("p",[v._v("基本流程：")]),v._v(" "),t("blockquote",[t("p",[v._v("正向传播时的流程为")]),v._v(" "),t("blockquote",[t("p",[v._v("循环，对t = 1,..., T")]),v._v(" "),t("p",[v._v("​\t用正向循环层进行正向传播，记住每一个时刻的输出值")]),v._v(" "),t("p",[v._v("结束循环")])]),v._v(" "),t("blockquote",[t("p",[v._v("循环，对t = T,..., 1")]),v._v(" "),t("p",[v._v("​\t用反向循环层进行正向传播，记住每一个时刻的输出值")]),v._v(" "),t("p",[v._v("结束循环")])]),v._v(" "),t("blockquote",[t("p",[v._v("循环，对所有的t，"),t("strong",[v._v("可按照任意顺序")]),v._v("进行计算")]),v._v(" "),t("p",[v._v("​\t用正向和反向循环层的输出值"),t("strong",[v._v("拼接起来作为输出层的输入")]),v._v("，计算最终的输出值")]),v._v(" "),t("p",[v._v("结束循环")])])]),v._v(" "),t("p",[v._v("图")]),v._v(" "),t("p",[t("img",{attrs:{src:"/imgs/image-20191003131423819.png",alt:""}})])])}),[],!1,null,null,null);_.default=o.exports}}]);